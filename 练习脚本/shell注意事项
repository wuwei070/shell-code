1. 本地编写的代码传到服务器后一定要确认是否是unix格式的，否则会出现很多异常之外的错误，切记，切记
2.怎么把本地代码弄成传到服务器也是unix格式的
3.用什么命令查询传到服务器的脚本是unix格式的
4.如果一个脚本要设置一个环境变量, 那么需要将这些变量"export"出来, 也就是需要通知到脚本本地的环境. 这是export命令的功能.

let "1<2" returns 0 (as "1<2" expands to "1")
(( 0 && 1 )) returns 1 (as "0 && 1" expands to "0") # (( ... ))和let ...结构也能够返回退出状态码, 当它们所测试的算术表达式的结果为非零的时候, 将会返回退出状态码0. (不知道为啥要这样)
find "somedir" -type l -print0| xargs -r0 file| grep "broken symbolic"| sed -e 's/^\|: *broken symbolic.*$/"/g' print0和xargs的-0是配合使用的; 但在某些情况下，如果没有要处理的内容，你可能希望停止 xargs；如果是这样，能使用 -r 选项; sed -e 's/^\|: *broken symbolic.*$/"/g' 管道符|是或的关系，表示开头或者后面匹配到的替换成双引号"

eq是整数比较，==是字符串比较
<
小于(在双括号中使用)

(("$a" < "$b")) 整数比较是在双括号。而下面的字符串比较，不是在双括号



if [[ "$a" < "$b" ]]

if [ "$a" \< "$b" ]

注意"<"使用在[ ]结构中的时候需要被转义.

-z
字符串为"null", 意思就是字符串长度为零

-n
字符串不为"null".
当-n使用在中括号中进行条件测试的时候, 必须要把字符串用双引号引用起来. 如果采用了未引用的字符串来使用! -z, 甚至是在条件测试中括号中只使用未引用的字符串的话, 一般也是可以工作的, 然而, 这是一种不安全的习惯. 习惯于使用引用的测试字符串才是正路. [

-a
逻辑与

exp1 -a exp2 如果表达式exp1和exp2都为真的话, 那么结果为真.

-o
逻辑或

exp1 -o exp2 如果表达式exp1和exp2中至少有一个为真的话, 那么结果为真.

这与Bash中的比较操作符&&和||非常相像, 但是这个两个操作符是用在双中括号结构中的.

  1 [[ condition1 && condition2 ]]
-o和-a操作符一般都是和test命令或者是单中括号结构一起使用的.
  1 if [ "$exp1" -a "$exp2" ]

 在一个混合测试中, 即使使用引用的字符串变量也可能还不够. 如果$string为空的话, [ -n "$string" -o "$a" = "$b" ]可能会在某些版本的Bash中产生错误. 安全的做法是附加一个额外的字符给可能的空变量, [ "x$string" != x -o "x$a" = "x$b" ] ("x"字符是可以相互抵消的).

 

