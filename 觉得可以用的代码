cat /dev/null > messages  #清空一个文件
exit # 这个命令是一种正确并且合适的退出脚本的方法.
再次提醒你#!/bin/sh将会调用默认的shell解释器, 在Linux机器上默认是/bin/bash.写这个可以容易的移植到non-linux机器上
小心: 使用sh scriptname来调用脚本的时候将会关闭一些Bash特定的扩展, 脚本可能因此而调用失败.
echo $(( 2#101011 ))  #数制转换

逗号操作符. 逗号操作符链接了一系列的算术操作. 虽然里边所有的内容都被运行了,但只有最后一项被返回.
    1 let "t2 = ((a = 9, 15 / 3))"  # Set "a = 9" and "t2 = 15 / 3"
空命令[冒号, 即:]. 等价于"NOP" (no op, 一个什么也不干的命令). 也可以被认为与shell的内建命令true作用相同. ":"命令是一个bash的内建命令, 它的退出码(exit status)是"true"(0).

4. : ${username=`whoami`}
  2 # ${username=`whoami`}   如果没有开头的":"的话, 将会给出一个错误, 
  3 #                        除非"username"是一个命令或者内建命令...

$
行结束符. 在正则表达式中, "$"表示行结束符.

${}
参数替换.

$*, $@
位置参数.

$?
退出状态码变量. $? 变量 保存了一个命令, 一个函数, 或者是脚本本身的退出状态码.

$$
进程ID变量. 这个$$ 变量 保存了它所在脚本的进程 ID [1]

初始化数组.

  1 Array=(element1 element2 element3)

大括号扩展 {xxx,yyy,zzz,...}
    cat {file1,file2,file3} > combined_file
    cp file22.{txt,backup}
    echo {file1,file2}\ :{\ A," B",' C'}  #在大括号中, 不允许有空白, 除非这个空白被引用或转义.  file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C

a=123
( a=321; )	      
echo "a = $a"   # a = 123   # 在圆括号中a变量, 更像是一个局部变量. 
小括号和大括号的区别。同时， {大括号}中的代码块将不会开启一个新的子shell.
a=123
{ a=321; }
echo "a = $a"   # a = 321   (说明在代码块中对变量a所作的修改, 影响了外边的变量)

{} \; 一般都在find命令中使用. 这不是一个shell内建命令. ";"用来结束find命令序列的-exec选项. 它需要被保护以防止被shell所解释.

command &>filename 重定向command的stdout和stderr到filename中.
command >&2 重定向command的stdout到stderr中.

[root@localhost tmp]# grep '\<the\>' 1.txt  #匹配行首的the  正则表达式中的单词边界 
the asdfthe
[root@localhost tmp]# grep the 1.txt  #匹配这行的所有the
the asdfthe

(cd /source/directory && tar cf - . ) | (cd /dest/directory && tar xpvf -) #从一个目录移动整个目录树到另一个目录。mv不就好了，这里只是告诉我们这种用法

怎么在文件的开头添加几行？
file=data.txt
title="***This is the title line of data text file***"

echo $title | cat - $file >$file.new
# "cat -" 将stdout连接到$file.
#  最后的结果就是生成了一新文件, 
#+ 并且成功的将$title的内容附加到了文件的*开头*. 

注意$variable事实上只是${variable}的简写形式. 在某些上下文中$variable可能会引起错误, 这时候你就需要用${variable}了
# 强烈注意, 在赋值的的时候, 等号前后一定不要有空格.

hello="A B  C   D"
echo $hello   # A B C D
echo "$hello" # A B  C   D
# 就象你看到的echo $hello   和    echo "$hello"   将给出不同的结果.
# ===============================================================
# 引用一个变量将保留其中的空白, 当然, 如果是变量替换就不会保留了.  “”是弱引用，''是强引用

``和R=$(cat /etc/redhat-release) 都是命令替换的一种形式
a=2334
b=${a/23/BB}             # 将"23"替换成"BB".

位置参数
从命令行传递到脚本的参数: $0, $1, $2, $3 . . .

$0就是脚本文件自身的名字, $1 是第一个参数, $2是第二个参数, $3是第三个参数, 然后是第四个. [1] $9之后的位置参数就必须用大括号括起来了, 比如, ${10}, ${11}, ${12}.

两个比较特殊的变量$*和$@ 表示所有的位置参数.
echo "All the command-line parameters are: "$*""  表示对应的位置参数
if [ $# -lt "$MINPARAMS" ]   表示数量

‘{}‘}标记法提供了一种提取从命令行传递到脚本的最后一个位置参数的简单办法. 但是这种方法同时还需要使用间接引用.
args=$#           # 位置参数的个数.
lastarg=${!args}
# 或:       lastarg=${!#}
#           (感谢, Chris Monson.)
# 注意, 不能直接使用 lastarg=${!$#} , 这会产生错误.

#!/bin/bash
# 使用'shift'来逐步存取所有的位置参数. 参数一个个传进去，然后处理完后再处理下一个

#  给脚本命个名, 比如shft,
#+ 然后给脚本传递一些位置参数, 比如: 
#          ./shft a b c def 23 skidoo

until [ -z "$1" ]  # 直到所有的位置参数都被存取完...
do
  echo -n "$1 "
  shift
done

echo               # 额外的换行.

exit 0

escape=$'\033'                    # 033 是八进制码的esc.想要查什么特殊代码，查ascii表
# 如果使用$'\X'结构,那-e选项就不必要了.
echo; echo "NEWLINE AND BEEP"
echo $'\n'           # 新行.
echo $'\a'           # 警告(蜂鸣).

例子：自动登录mysql（root:root,passwd:123456),查询test库，test1表里的user=aa的记录。

复制代码代码如下:

#!/bin/sh
mysql -uroot -p123456 <<EOF
use test;
select * from testaa while a=10000; ###1000 not usr single quote mark,because a is int
# type,only char type need single quote mark.
exit
EOF

root@LAPTOP-7RN4GA8H:~# cat >> 1.txt << EOF
> AAA
> BBB
> EOF
