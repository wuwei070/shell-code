cat /dev/null > messages  #清空一个文件
exit # 这个命令是一种正确并且合适的退出脚本的方法.
再次提醒你#!/bin/sh将会调用默认的shell解释器, 在Linux机器上默认是/bin/bash.写这个可以容易的移植到non-linux机器上
小心: 使用sh scriptname来调用脚本的时候将会关闭一些Bash特定的扩展, 脚本可能因此而调用失败.
echo $(( 2#101011 ))  #数制转换

逗号操作符. 逗号操作符链接了一系列的算术操作. 虽然里边所有的内容都被运行了,但只有最后一项被返回.
    1 let "t2 = ((a = 9, 15 / 3))"  # Set "a = 9" and "t2 = 15 / 3"
空命令[冒号, 即:]. 等价于"NOP" (no op, 一个什么也不干的命令). 也可以被认为与shell的内建命令true作用相同. ":"命令是一个bash的内建命令, 它的退出码(exit status)是"true"(0).

4. : ${username=`whoami`}
  2 # ${username=`whoami`}   如果没有开头的":"的话, 将会给出一个错误, 
  3 #                        除非"username"是一个命令或者内建命令...

$
行结束符. 在正则表达式中, "$"表示行结束符.

${}
参数替换.

$*, $@
位置参数.

$?
退出状态码变量. $? 变量 保存了一个命令, 一个函数, 或者是脚本本身的退出状态码.

$$
进程ID变量. 这个$$ 变量 保存了它所在脚本的进程 ID [1]

初始化数组.

  1 Array=(element1 element2 element3)

大括号扩展 {xxx,yyy,zzz,...}
    cat {file1,file2,file3} > combined_file
    cp file22.{txt,backup}
    echo {file1,file2}\ :{\ A," B",' C'}  #在大括号中, 不允许有空白, 除非这个空白被引用或转义.  file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C

a=123
( a=321; )	      
echo "a = $a"   # a = 123   # 在圆括号中a变量, 更像是一个局部变量. 
小括号和大括号的区别。同时， {大括号}中的代码块将不会开启一个新的子shell.
a=123
{ a=321; }
echo "a = $a"   # a = 321   (说明在代码块中对变量a所作的修改, 影响了外边的变量)

{} \; 一般都在find命令中使用. 这不是一个shell内建命令. ";"用来结束find命令序列的-exec选项. 它需要被保护以防止被shell所解释.

command &>filename 重定向command的stdout和stderr到filename中.
command >&2 重定向command的stdout到stderr中.

[root@localhost tmp]# grep '\<the\>' 1.txt  #匹配行首的the  正则表达式中的单词边界 
the asdfthe
[root@localhost tmp]# grep the 1.txt  #匹配这行的所有the
the asdfthe

(cd /source/directory && tar cf - . ) | (cd /dest/directory && tar xpvf -) #从一个目录移动整个目录树到另一个目录。mv不就好了，这里只是告诉我们这种用法

怎么在文件的开头添加几行？
file=data.txt
title="***This is the title line of data text file***"

echo $title | cat - $file >$file.new
# "cat -" 将stdout连接到$file.
#  最后的结果就是生成了一新文件, 
#+ 并且成功的将$title的内容附加到了文件的*开头*. 

注意$variable事实上只是${variable}的简写形式. 在某些上下文中$variable可能会引起错误, 这时候你就需要用${variable}了
# 强烈注意, 在赋值的的时候, 等号前后一定不要有空格.

hello="A B  C   D"
echo $hello   # A B C D
echo "$hello" # A B  C   D
# 就象你看到的echo $hello   和    echo "$hello"   将给出不同的结果.
# ===============================================================
# 引用一个变量将保留其中的空白, 当然, 如果是变量替换就不会保留了.  “”是弱引用，''是强引用

``和R=$(cat /etc/redhat-release) 都是命令替换的一种形式
a=2334
b=${a/23/BB}             # 将"23"替换成"BB".

位置参数
从命令行传递到脚本的参数: $0, $1, $2, $3 . . .

$0就是脚本文件自身的名字, $1 是第一个参数, $2是第二个参数, $3是第三个参数, 然后是第四个. [1] $9之后的位置参数就必须用大括号括起来了, 比如, ${10}, ${11}, ${12}.

两个比较特殊的变量$*和$@ 表示所有的位置参数.
echo "All the command-line parameters are: "$*""  表示对应的位置参数
if [ $# -lt "$MINPARAMS" ]   表示数量

‘{}‘}标记法提供了一种提取从命令行传递到脚本的最后一个位置参数的简单办法. 但是这种方法同时还需要使用间接引用.
args=$#           # 位置参数的个数.
lastarg=${!args}
# 或:       lastarg=${!#}
#           (感谢, Chris Monson.)
# 注意, 不能直接使用 lastarg=${!$#} , 这会产生错误.

#!/bin/bash
# 使用'shift'来逐步存取所有的位置参数. 参数一个个传进去，然后处理完后再处理下一个

#  给脚本命个名, 比如shft,
#+ 然后给脚本传递一些位置参数, 比如: 
#          ./shft a b c def 23 skidoo

until [ -z "$1" ]  # 直到所有的位置参数都被存取完...
do
  echo -n "$1 "
  shift
done

echo               # 额外的换行.

exit 0

escape=$'\033'                    # 033 是八进制码的esc.想要查什么特殊代码，查ascii表
# 如果使用$'\X'结构,那-e选项就不必要了.
echo; echo "NEWLINE AND BEEP"
echo $'\n'           # 新行.
echo $'\a'           # 警告(蜂鸣).

例子：自动登录mysql（root:root,passwd:123456),查询test库，test1表里的user=aa的记录。

复制代码代码如下:

#!/bin/sh
mysql -uroot -p123456 <<EOF
use test;
select * from testaa while a=10000; ###1000 not usr single quote mark,because a is int
# type,only char type need single quote mark.
exit
EOF

root@LAPTOP-7RN4GA8H:~# cat >> 1.txt << EOF
> AAA
> BBB
> EOF

if cmp a b &> /dev/null; then
  echo "Files a and b are identical."
else
  echo "Files a and b differ."
fi 

# 非常有用的"if-grep"结构:
# ------------------------
if grep -q Bash file
then echo "File contains at least one occurrence of Bash."
fi

#  小技巧:
#  如果你不能够确定一个特定的条件该如何进行判断,
#+ 那么就使用if-test结构. 

echo

echo "Testing \"0\""
if [ 0 ]      # zero
then
  echo "0 is true."
else
  echo "0 is false."
fi            # 0 为真.

/usr/bin/test, [ ], 和/usr/bin/[都是等价命令
[[ ]]结构比[ ]结构更加通用. 这是一个扩展的test命令, 是从ksh88中引进的.
在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割, 但是会发生参数扩展和命令替换.
使用[[ ... ]]条件判断结构, 而不是[ ... ], 能够防止脚本中的许多逻辑错误. 比如, &&, ||, <, 和> 操作符能够正常存在于[[ ]]条件判断结构中, 但是如果出现在[ ]结构中的话, 会报错.

在if后面也不一定非得是test命令或者是用于条件判断的中括号结构( [ ] 或 [[ ]] ).

  1 dir=/home/bozo
  2 
  3 if cd "$dir" 2>/dev/null; then   # "2>/dev/null" 会隐藏错误信息.
  4   echo "Now in $dir."
  5 else
  6   echo "Can't change to $dir."
  7 fi
"if COMMAND"结构将会返回COMMAND的退出状态码.

与此相似, 在中括号中的条件判断也不一定非得要if不可, 也可以使用列表结构.

  1 var1=20
  2 var2=22
  3 [ "$var1" -ne "$var2" ] && echo "$var1 is not equal to $var2"
  4 
  5 home=/home/bozo
  6 [ -d "$home" ] || echo "$home directory does not exist."

  (( ))结构扩展并计算一个算术表达式的值. 如果表达式的结果为0, 那么返回的退出状态码为1, 或者是"假". 而一个非零值的表达式所返回的退出状态码将为0, 或者是"true". 这种情况和先前所讨论的test命令和[ ]结构的行为正好相反.

    (( 5 > 4 ))                                      # 真
    echo "Exit status of \"(( 5 > 4 ))\" is $?."     # 0

7.2. 文件测试操作符
如果下面的条件成立将会返回真.

-e
文件存在

-a
文件存在

这个选项的效果与-e相同. 但是它已经被"弃用"了, 并且不鼓励使用.

-f
表示这个文件是一个一般文件(并不是目录或者设备文件)

-s
文件大小不为零

-d
表示这是一个目录

-b
表示这是一个块设备(软盘, 光驱, 等等.)

-c
表示这是一个字符设备(键盘, modem, 声卡, 等等.)

-p
这个文件是一个管道

-h
这是一个符号链接

-L
这是一个符号链接

-S
表示这是一个socket

-t
文件(描述符)被关联到一个终端设备上

这个测试选项一般被用来检测脚本中的stdin([ -t 0 ]) 或者stdout([ -t 1 ])是否来自于一个终端.

-r
文件是否具有可读权限(指的是正在运行这个测试命令的用户是否具有读权限)

-w
文件是否具有可写权限(指的是正在运行这个测试命令的用户是否具有写权限)

-x
文件是否具有可执行权限(指的是正在运行这个测试命令的用户是否具有可执行权限)

-g
set-group-id(sgid)标记被设置到文件或目录上

如果目录具有sgid标记的话, 那么在这个目录下所创建的文件将属于拥有这个目录的用户组, 而不必是创建这个文件的用户组. 这个特性对于在一个工作组中共享目录非常有用.

-u
set-user-id (suid)标记被设置到文件上

如果一个root用户所拥有的二进制可执行文件设置了set-user-id标记位的话, 那么普通用户也会以root权限来运行这个文件. [1] 这对于需要访问系统硬件的执行程序(比如pppd和cdrecord)非常有用. 如果没有suid标志的话, 这些二进制执行程序是不能够被非root用户调用的.

	      -rwsr-xr-t    1 root       178236 Oct  2  2000 /usr/sbin/pppd
	      
对于设置了suid标志的文件, 在它的权限列中将会以s表示.
-k
设置粘贴位

对于"粘贴位"的一般了解, save-text-mode标志是一个文件权限的特殊类型. 如果文件设置了这个标志, 那么这个文件将会被保存到缓存中, 这样可以提高访问速度. [2] 粘贴位如果设置在目录中, 那么它将限制写权限. 对于设置了粘贴位的文件或目录, 在它们的权限标记列中将会显示t.

	      drwxrwxrwt    7 root         1024 May 19 21:26 tmp/
	      
如果用户并不拥有这个设置了粘贴位的目录, 但是他在这个目录下具有写权限, 那么这个用户只能在这个目录下删除自己所拥有的文件. 这将有效的防止用户在一个公共目录中不慎覆盖或者删除别人的文件. 比如说/tmp目录. (当然, 目录的所有者或者root用户可以随意删除或重命名其中的文件.)
-O
判断你是否是文件的拥有者

-G
文件的group-id是否与你的相同

-N
从文件上一次被读取到现在为止, 文件是否被修改过

f1 -nt f2
文件f1比文件f2新

f1 -ot f2
文件f1比文件f2旧

f1 -ef f2
文件f1和文件f2是相同文件的硬链接

!
"非" -- 反转上边所有测试的结果(如果没给出条件, 那么返回真).

例子 7-4. 测试那些断掉的链接文件

  1 #!/bin/bash
  2 # broken-link.sh
  3 # 由Lee bigelow所编写 <ligelowbee@yahoo.com>
  4 # 已经争得作者的授权引用在本书中.
  5 
  6 #一个纯粹的shell脚本用来找出那些断掉的符号链接文件并且输出它们所指向的文件.
  7 #以便于它们可以把输出提供给xargs来进行处理 :)
  8 #比如. broken-link.sh /somedir /someotherdir|xargs rm
  9 #
 10 #下边的方法, 不管怎么说, 都是一种更好的办法:
 11 #
 12 #find "somedir" -type l -print0|\
 13 #xargs -r0 file|\
 14 #grep "broken symbolic"|
 15 #sed -e 's/^\|: *broken symbolic.*$/"/g'
 16 #
 17 #但这不是一个纯粹的bash脚本, 最起码现在不是.
 18 #注意: 谨防在/proc文件系统和任何死循环链接中使用!
 19 ##############################################################
 20 
 21 
 22 #如果没有参数被传递到脚本中, 那么就使用
 23 #当前目录. 否则就是用传递进来的参数作为目录
 24 #来搜索.
 25 ####################
 26 [ $# -eq 0 ] && directorys=`pwd` || directorys=$@
 27 
 28 #编写函数linkchk用来检查传递进来的目录或文件是否是链接, 
 29 #并判断这些文件或目录是否存在. 然后打印它们所指向的文件.
 30 #如果传递进来的元素包含子目录, 
 31 #那么把子目录也放到linkcheck函数中处理, 这样就达到了递归的目的.
 32 ##########
 33 linkchk () {
 34     for element in $1/*; do
 35     [ -h "$element" -a ! -e "$element" ] && echo \"$element\"
 36     [ -d "$element" ] && linkchk $element
 37     # 当然, '-h'用来测试符号链接, '-d'用来测试目录.
 38     done
 39 }
 40 
 41 #把每个传递到脚本的参数都送到linkchk函数中进行处理, 
 42 #检查是否有可用目录. 如果没有, 那么就打印错误消息和
 43 #使用信息.
 44 ################
 45 for directory in $directorys; do
 46     if [ -d $directory ]
 47 	then linkchk $directory
 48 	else 
 49 	    echo "$directory is not a directory"
 50 	    echo "Usage: $0 dir1 dir2 ..."
 51     fi
 52 done
 53 
 54 exit 0
例子 28-1, 例子 10-7, 例子 10-3, 例子 28-3, 和例子 A-1也会演示文件测试操作的使用过程.

注意事项
[1]	
在将suid标记设置到二进制可执行文件的时候, 一定要小心. 因为这可能会引发安全漏洞. 但是suid标记不会影响shell脚本.

[2]	
在当代UNIX系统中, 文件中已经不使用粘贴位了, 粘贴位只使用在目录中.

linkchk () {
  for element in $1/*; do
      [ -h "$element" -a ! -e "$element" ] && echo \"$element\"
      [ -d "$element" ] && linkchk $element
     # 当然, '-h'用来测试符号链接, '-d'用来测试目录.
  done
}             #递归的写法

算术操作符经常会出现在 expr或let表达式中.
  let "n = $n + 1"   # let "n = n + 1"  也可以.
  : $((n = $n + 1))
   #  ":" 是必需的, 因为如果没有":"的话, 
   #+ Bash将会尝试把"$((n = $n + 1))"解释为一个命令.
   (( n = n + 1 ))
   #  上边这句是一种更简单方法.
   let "n++" 
   (( n++ ))   # (( ++n )  也可以.
   	
Bash不能够处理浮点运算. 它会把包含小数点的数字看作字符串. let "b = $a + 1.3"  # 错误. 如果非要做浮点运算的话, 可以在脚本中使用bc, 这个命令可以进行浮点运算, 或者调用数学库函数.
[root@lancy bin]# echo "scale=2; 5/3" |bc
1.66
[root@lancy bin]# echo "ibase=10;obase=2; 4*6"|bc
11000

&&
与(逻辑)

  1 if [ $condition1 ] && [ $condition2 ]
  2 # 与 if [ $condition1 -a $condition2 ] 相同
  3 # 如果condition1和condition2都为true, 那结果就为true. 
  4 
  5 if [[ $condition1 && $condition2 ]]    # 也可以.
  6 # 注意: &&不允许出现在[ ... ]结构中.

逗号操作符可以连接两个或多个算术运算. 所有的操作都会被运行(可能会有负作用), 但是只会返回最后操作的结果.

  1 let "t1 = ((5 + 3, 7 - 1, 15 - 4))"
  2 echo "t1 = $t1"               # t1 = 11
  3 
  4 let "t2 = ((a = 9, 15 / 3))"  # 设置"a"并且计算"t2".
  5 echo "t2 = $t2    a = $a"     # t2 = 5    a = 9

  shell脚本在默认情况下都是把数字作为10进制数来处理, 除非这个数字采用了特殊的标记或者前缀. 如果数字以0开头的话那么就是8进制数. 如果数字以0x开头的话那么就是16进制数. 如果数字中间嵌入了#的话, 
  那么就被认为是BASE#NUMBER形式的标记法(有范围和符号限制).

  # 8进制: 以'0'(零)开头 
  let "oct = 032"
  echo "octal number = $oct"               # 26
  # 表达式结果是用10进制表示的.

  let "hex = 0x32"
  echo "hexadecimal number = $hex"         # 50
  # 表达式结果是用10进制表示的.
  
  # 其他进制: BASE#NUMBER
  # BASE的范围在2到64之间.
  # NUMBER的值必须使用BASE范围内的符号来表示, 具体看下边的示例. 
  
  let "bin = 2#111100111001101"
  echo "binary number = $bin"              # 31181
 
  let "b32 = 32#77"
 30 echo "base-32 number = $b32"             # 231

 let "b64 = 64#@_"
 echo "base-64 number = $b64"             # 4031
 # 这个表示法只能工作于受限的ASCII字符范围(2 - 64).
 # 10个数字 + 26个小写字母 + 26个大写字符 + @ + _
 检查$BASH_VERSION对于判断系统上到底运行的是哪个shell来说是一种非常好的方法. 变量$SHELL有时候不能够给出正确的答案.
 $IFS
内部域分隔符

这个变量用来决定Bash在解释字符串时如何识别域, 或者单词边界.

$IFS默认为空白(空格, 制表符,和换行符), 但这是可以修改的, 比如, 在分析逗号分隔的数据文件时, 
就可以设置为逗号. 注意$*使用的是保存在$IFS中的第一个字符. 
  bash -c 'set w x y z; IFS=":-;"; echo "$*"'

(shopt -s dotglob; rm -f *) #可以删除显示和隐藏的文件

$TMOUT
如果$TMOUT环境变量被设置为非零值time的话, 那么经过time秒后, shell提示符将会超时. 这将会导致登出(logout).

在2.05b版本的Bash中, $TMOUT变量与命令read可以在脚本中结合使用.

  1 # 只能够在Bash脚本中使用, 必须使用2.05b或之后版本的Bash.
  2 
  3 TMOUT=3    # 提示输入时间为3秒.
  4 
  5 echo "What is your favorite song?"
  6 echo "Quickly now, you only have $TMOUT seconds to answer!"
  7 read song
  8 
  9 if [ -z "$song" ]
 10 then
 11   song="(no answer)"
 12   # 默认响应.
 13 fi
 14 
 15 echo "Your favorite song is $song."

 $*
所有的位置参数都被看作为一个单词.

Note	
"$*"必须被引用起来.

$@
与$*相同, 但是每个参数都是一个独立的引用字符串, 这就意味着, 参数是被完整传递的, 并没有被解释或扩展. 这也意味着, 参数列表中每个参数都被看作为单独的单词.

Note	
当然, "$@"应该被引用起来.

$@与$*中的参数只有在被双引号引用起来的时候才会不同.

$-
传递给脚本的标记(使用set命令). 参见例子 11-15.
$_
这个变量保存之前执行的命令的最后一个参数的值.
$!
运行在后台的最后一个作业的PID(进程ID)
  1 LOG=$0.log
  2 
  3 COMMAND1="sleep 100"
  4 
  5 echo "Logging PIDs background commands for script: $0" >> "$LOG"
  6 # 所以它们是可以被监控的, 并且可以在必要的时候kill掉它们.
  7 echo >> "$LOG"
  8 
  9 # 记录命令.
 10 
 11 echo -n "PID of \"$COMMAND1\":  " >> "$LOG"
 12 ${COMMAND1} &
 13 echo $! >> "$LOG"
 14 # "sleep 100"的PID:  1506
 15 
 16 # 感谢, Jacques Lederer, 对此的建议.

$?
命令, 函数, 或者是脚本本身的(参见例子 23-7)退出状态码

$$
脚本自身的进程ID. $$变量在脚本中经常用来构造"唯一的"临时文件名，这么做通常比调用mktemp命令来的简单.